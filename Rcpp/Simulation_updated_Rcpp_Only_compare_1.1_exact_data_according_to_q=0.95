#include <Rcpp.h>
#include <algorithm>

using namespace Rcpp;


// [[Rcpp::export]]
NumericMatrix rcpp_only_diag_cumprod(NumericVector v){
  int r = v.size();
  NumericVector cump_rev = cumprod(rev(v));
  NumericVector rev_cump_rev = rev(cump_rev);
  NumericMatrix out(r); //equivalent to matrix(0, nrow = 2, ncol = 2)
  for(int i=0; i<r; ++i){
    for(int j=0; j<r; ++j){
      if(i==j){
        out(i,j) = rev_cump_rev[i];
      }else{
        out(i,j) = 0;
      }
    }
  }
  return out;
}


// [[Rcpp::export]]
NumericMatrix matrix_multiply(NumericMatrix A, NumericMatrix B){
  int n = A.nrow(), r = A.ncol(), p = B.ncol();
  NumericMatrix out(n,p);
  for(int i=0; i<n; ++i){
    for(int j=0; j<p; ++j){
      double temp = 0;
      for(int k=0; k<r; ++k){
        temp = temp + (A(i,k) * B(k,j));
      }
      out(i,j) = temp;
    }
  }
  return out;
}


// [[Rcpp::export]]
NumericMatrix matrix_add(NumericMatrix A, NumericMatrix B){
  int n = A.nrow(), p = A.ncol();
  NumericMatrix out(n,p);
  for(int i=0; i<n; ++i){
    for(int j=0; j<p; ++j){
      out(i,j) = A(i,j) + B(i,j);
    }
  }
  return out;
}


// [[Rcpp::export]]
NumericMatrix matrix_scalar_multiply(double k, NumericMatrix A){
  int n = A.nrow(), p = A.ncol();
  NumericMatrix out(n,p);
  for(int i=0; i<n; ++i){
    for(int j=0; j<p; ++j){
      out(i,j) = k*A(i,j);
    }
  }
  return out;
}


// [[Rcpp::export]]
NumericMatrix rcpp_only_rustiefel(int n, int r){ 
  Environment rstiefel("package:rstiefel");
  Function rustiefel = rstiefel["rustiefel"];
  NumericMatrix out = rustiefel(n,r);
  return out;
}


// [[Rcpp::export]]
NumericMatrix rcpp_only_rmf_matrix(NumericMatrix M){ 
  Environment rstiefel("package:rstiefel");
  Function rmf_matrix = rstiefel["rmf.matrix"];
  NumericMatrix out = rmf_matrix(M);
  return out;
}


// [[Rcpp::export]]
double rcpp_only_rtruncnorm(double a, double b, double mean, double sd){
  Environment truncnorm("package:truncnorm"); 
  Function rtruncnorm = truncnorm["rtruncnorm"];
  SEXP out1 = rtruncnorm(1, a, b, mean, sd);
  double out = Rcpp::as<double>(out1);
  return out;   
}


// [[Rcpp::export]]
double rcpp_only_rinvgamma(double shape, double rate){ 
  Environment invgamma("package:invgamma"); 
  Function rinvgamma = invgamma["rinvgamma"];
  SEXP out1 = rinvgamma(Named("n", 1), Named("shape", shape), Named("rate", rate));
  double out = as<double>(out1);
  return out;   
}


// [[Rcpp::export]]
double rcpp_only_invgamma(double shape, double rate){
  double scale = 1/rate;
  double out_gamma = Rcpp::rgamma(1, shape, scale)[0];
  double out = 1/(out_gamma);
  return out;
}


// [[Rcpp::export]]
NumericVector rcpp_only_d_update_mat(NumericVector d, NumericMatrix A, double Sigma2, int n, int p, int r) {
  //RNGScope scope; ??
  for(int i = 0; i < r; ++i){
    NumericMatrix D_cap(r);
    for(int j=0; j< r; ++j){
      for(int k=0; k< r; ++k){
        if((j == k) && (j <= i)){
          D_cap(j,j) = 1;
          for(int l=j; l< r; ++l){
            if(l==i){
              D_cap(j,j) = D_cap(j,j);
            }else{
              D_cap(j,j) = D_cap(j,j) * d[l];
            }
          }
        }
        else
          D_cap(j,k) = 0;
      }
    }
    
    /*  
     D_cap = D_cap/d[i];
     
     double num = matrix_trace(matrix_multiply(D_cap,A));
     double denom = matrix_trace(matrix_dot_multiply(D_cap,D_cap)) + Sigma2;
     double mu = num/denom;
     double sigma = sqrt(Sigma2/denom);
     
     if (i < r-1){
     d[i] = rcpp_only_rtruncnorm(1, R_PosInf, mu, sigma);
     }
     else{
     d[i] = rcpp_only_rtruncnorm(0, R_PosInf, mu, sigma);
     }
     */    
    
    double num = 0;
    for(int j=0; j<r; ++j){
      num = num + (D_cap(j,j)*A(j,j));
    }
    
    double denom = 0;
    for(int j=0; j<r; ++j){
      denom = denom + pow(D_cap(j,j), 2.0);
    }
    denom = denom + Sigma2;
    
    if (i < r-1){
      d[i] = rcpp_only_rtruncnorm(1, R_PosInf, num/denom, sqrt(Sigma2/denom));
    }
    else{
      d[i] = rcpp_only_rtruncnorm(0, R_PosInf, num/denom, sqrt(Sigma2/denom));
    }
    
  }
  return d;
}


// creating the function for 1:burn_in below:

// [[Rcpp::export]]
List Simul_burnin(NumericMatrix Y, NumericMatrix U, NumericMatrix U2, NumericMatrix D, NumericMatrix D2, NumericMatrix V, NumericMatrix V2, NumericMatrix S, NumericMatrix S2, NumericVector d, NumericVector d2, double Sigma2, double Sigma22, double tow2, double q1, double q2, int n, int p, int r, int burn_in, double a, double b){
  int c = 0;
  
  NumericMatrix L(n,p);
  NumericMatrix L2(n,p);
  NumericMatrix S_count(n,p);
  NumericMatrix S_count2(n,p);
  
  for(int count = 0; count < burn_in; ++count){
    
    //double inv_Sigma2 = 1/Sigma2;
    //double inv_Sigma22 = 1/Sigma22;
    
    // Update the value of U for Method 1 and 2
    NumericMatrix U11(n,r);
    NumericMatrix U22(n,r);
    for(int i=0; i <n; ++i){
      for(int l=0; l<r; ++l){
        double temp1 = 0;
        double temp2 = 0;
        for(int j=0; j<p; ++j){
          temp1 = temp1 + (((Y(i,j) - S(i,j))*V(j,l)*D(l,l))/Sigma2);
          temp2 = temp2 + (((Y(i,j) - S2(i,j))*V2(j,l)*D2(l,l))/Sigma22);
        }
        U11(i,l) = temp1;
        U22(i,l) = temp2;
      }
    }
    
    U = rcpp_only_rmf_matrix(U11);
    //    Rcout << "The value of U : \n" << U << "\n";
    U2 = rcpp_only_rmf_matrix(U22);
    //    Rcout << "The value of U2 : \n" << U2 << "\n";
    
    // Update the value of V for Method 1 and 2
    NumericMatrix V11(p,r);
    NumericMatrix V22(p,r);
    for(int j=0; j <p; ++j){
      for(int l=0; l<r; ++l){
        double temp1 = 0;
        double temp2 = 0;
        for(int i=0; i<n; ++i){
          temp1 = temp1 + (((Y(i,j) - S(i,j))*U(i,l)*D(l,l))/Sigma2);
          temp2 = temp2 + (((Y(i,j) - S2(i,j))*U2(i,l)*D2(l,l))/Sigma22);
        }
        V11(j,l) = temp1;
        V22(j,l) = temp2;
      }
    }
    
    V = rcpp_only_rmf_matrix(V11);
    //    Rcout << "The value of V : \n" << V << "\n";
    V2 = rcpp_only_rmf_matrix(V22);
    //    Rcout << "The value of V2 : \n" << V2 << "\n";
    
    
    // Update the value of d one at a time for Method 1 and 2
    d = rcpp_only_d_update_mat(clone(d), matrix_multiply(transpose(matrix_multiply(matrix_add(Y, matrix_scalar_multiply(-1, S)), V)), U), Sigma2, n, p, r);
    //    Rcout << "The value of d : \n" << d << "\n";
    d2 = rcpp_only_d_update_mat(clone(d2), matrix_multiply(transpose(matrix_multiply(matrix_add(Y, matrix_scalar_multiply(-1, S2)), V2)), U2), Sigma22, n, p, r);
    //    Rcout << "The value of d2 : \n" << d2 << "\n";
    
    // Once we got the updated set of elements in vector d, it's time to Update D for both Methods
    D = rcpp_only_diag_cumprod(d);
    //    Rcout << "The value of D : \n" << D << "\n";
    D2 = rcpp_only_diag_cumprod(d2);
    //    Rcout << "The value of D2 : \n" << D2 << "\n";
    
    //    Rcout << "The value of L : \n" << L << "\n";
    //    Rcout << "The value of L2 : \n" << L2 << "\n";
    
    
    
    // Update the value of L and then S for Method 1 and 2
    NumericMatrix S_rnorm(n, p);
    NumericMatrix S_runif(n, p);
    NumericMatrix S_rnorm2(n, p);
    for(int j=0; j < p; ++j){
      S_rnorm(_ , j) = Rcpp::rnorm(n, 0, sqrt((tow2 * Sigma2)/(tow2 + Sigma2)));
      S_runif(_ , j) = Rcpp::runif(n, 0, 1);
      S_rnorm2(_ , j) = Rcpp::rnorm(n, 0, sqrt((tow2 * Sigma22)/(tow2 + Sigma22)));
    }
    
    // NumericMatrix S_mu_rnorm(n,p);
    // NumericMatrix Q_star_matrix(n, p);
    NumericMatrix S_MCC(n,p);
    // NumericMatrix S_mu_rnorm2(n,p);
    // NumericMatrix Q_star_matrix2(n,p);
    NumericMatrix S_MCC2(n,p);
    
    double rate = 0;
    double rate2 = 0;
    
    for(int i=0; i<n; ++i){
      for(int j=0; j<p; ++j){
        
        // It is needed for updating L
        double temp1 = 0;
        double temp2 = 0;
        for(int l=0; l<r; ++l){
          temp1 = temp1 + (U(i,l)*D(l,l)*V(j,l));
          temp2 = temp2 + (U2(i,l)*D2(l,l)*V2(j,l));
        }
        L(i,j) = temp1;
        L2(i,j) = temp2;    
        
        // It is needed for updating S
        // S_mu_rnorm(i,j) = ((tow2/(tow2 + Sigma2))*(Y(i,j) - L(i,j))) + S_rnorm(i,j);
        // S_mu_rnorm2(i,j) = ((tow2/(tow2 + Sigma22))*(Y(i,j) - L2(i,j))) + S_rnorm2(i,j);
        
        // Q_star_matrix(i,j) = q1/(q1 + (((1-q1) * sqrt(Sigma2) * exp((tow2 * pow(Y(i,j) - L(i,j), 2.0))/(2 * Sigma2 * (tow2 + Sigma2))))/sqrt(tow2 + Sigma2)));
        // Q_star_matrix2(i,j) = q2/(q2 + (((1-q2) * sqrt(Sigma22) * exp((tow2 * pow(Y(i,j) - L2(i,j), 2.0))/(2 * Sigma22 * (tow2 + Sigma22))))/sqrt(tow2 + Sigma22)));
        
        if(S_runif(i,j) > (q1/(q1 + (((1-q1) * sqrt(Sigma2) * exp((tow2 * pow(Y(i,j) - L(i,j), 2.0))/(2 * Sigma2 * (tow2 + Sigma2))))/sqrt(tow2 + Sigma2))))){
          S_MCC(i,j) = 1;
          S_count(i,j) = 0;
        }else{
          S_MCC(i,j) = 0;
          S_count(i,j) = 1;
        }
        
        if(S_runif(i,j) > (q2/(q2 + (((1-q2) * sqrt(Sigma22) * exp((tow2 * pow(Y(i,j) - L2(i,j), 2.0))/(2 * Sigma22 * (tow2 + Sigma22))))/sqrt(tow2 + Sigma22))))){
          S_MCC2(i,j) = 1;
          S_count2(i,j) = 0;
        }else{
          S_MCC2(i,j) = 0;
          S_count2(i,j) = 1;
        }
        
        S(i,j) = (((tow2/(tow2 + Sigma2))*(Y(i,j) - L(i,j))) + S_rnorm(i,j)) * S_MCC(i,j);
        S2(i,j) = (((tow2/(tow2 + Sigma22))*(Y(i,j) - L2(i,j))) + S_rnorm2(i,j)) * S_MCC2(i,j);
        
        rate = rate + pow(Y(i,j) - L(i,j) - S(i,j), 2.0);
        rate2 = rate2 + pow(Y(i,j) - L2(i,j) - S2(i,j), 2.0);
      }
    }
    
    //    Rcout << "The value of S : \n" << S << "\n";
    //    Rcout << "The value of S2 : \n" << S2 << "\n";
    // Update the value of Sigma2 for Method 1 and 2
    //    double shape = (n * p * 0.5) + a;
    //    rate = b + (0.5 * rate);
    //    rate2 = b + (0.5 * rate2);
    Sigma2 = rcpp_only_rinvgamma((n * p * 0.5) + a, b + (0.5 * rate));
    Sigma22 = rcpp_only_rinvgamma((n * p * 0.5) + a, b + (0.5 * rate2));
    //    Rcout << "The value of Sigma2 : \n" << Sigma2 << "\n";
    //    Rcout << "The value of Sigma22 : \n" << Sigma22 << "\n";
    
    c = c + 1;
    
  }
  
  return List::create(_["L"] = L, _["L2"] = L2, _["U"] = U, _["U2"] = U2, _["V"] = V, _["V2"] = V2, _["S"] = S, _["S2"] = S2, _["S_count"] = S_count, _["S_count2"] = S_count2, _["d"] = d, _["d2"] = d2, _["D"] = D, _["D2"] = D2, _["Sigma2"] = Sigma2, _["Sigma22"] = Sigma22, _["c"] = c);
}


// Creating the function for AFTER BURN IN:

// [[Rcpp::export]]
List Simul_after_burnin(NumericMatrix Y, NumericMatrix U, NumericMatrix U2, NumericMatrix D, NumericMatrix D2, NumericMatrix V, NumericMatrix V2, NumericMatrix L, NumericMatrix L2, NumericMatrix S, NumericMatrix S2, NumericMatrix S_count, NumericMatrix S_count2, NumericVector d, NumericVector d2, NumericVector d_star, double Sigma2, double Sigma22, double tow2, double q1, double q2, int n, int p, int r, int K, int burn_in, double a, double b){
  int c1 = 0;
  int c2 = 0;
  
  NumericVector d_sum = clone(d);
  NumericVector d_sum2 = clone(d2);
  NumericVector d_bar(r);
  NumericVector d_bar2(r);
  NumericMatrix L_sum = clone(L);
  NumericMatrix L_sum2 = clone(L2);
  NumericMatrix S_sum = clone(S);
  NumericMatrix S_sum2 = clone(S2);
  double Sigma2_sum = Sigma2;
  double Sigma2_sum2 = Sigma22;
  
  List dbar_list((K - burn_in)+1);
  dbar_list[0] = clone(d);
  List dbar_list2((K - burn_in)+1);
  dbar_list2[0] = clone(d2);
  
  NumericMatrix L_hat(n,p);
  NumericMatrix L_hat2(n,p);
  double Sigma2_bar = 0;
  double Sigma2_bar2 = 0;
  double distance_d = 0;
  double distance_d2 = 0;
  double distance_Sigma2 = 0;
  double distance_Sigma22 = 0;
  
  for(int count = 0; count < (K - burn_in); ++count){
    
    // Update the value of U for Method 1 and 2
    NumericMatrix U11(n,r);
    NumericMatrix U22(n,r);
    for(int i=0; i <n; ++i){
      for(int l=0; l<r; ++l){
        double temp1 = 0;
        double temp2 = 0;
        for(int j=0; j<p; ++j){
          temp1 = temp1 + (((Y(i,j) - S(i,j))*V(j,l)*D(l,l))/Sigma2);
          temp2 = temp2 + (((Y(i,j) - S2(i,j))*V2(j,l)*D2(l,l))/Sigma22);
        }
        U11(i,l) = temp1;
        U22(i,l) = temp2;
      }
    }
    
    U = rcpp_only_rmf_matrix(U11);
    //    Rcout << "The value of U : \n" << U << "\n";
    U2 = rcpp_only_rmf_matrix(U22);
    //    Rcout << "The value of U2 : \n" << U2 << "\n";
    
    // Update the value of V for Method 1 and 2
    NumericMatrix V11(p,r);
    NumericMatrix V22(p,r);
    for(int j=0; j <p; ++j){
      for(int l=0; l<r; ++l){
        double temp1 = 0;
        double temp2 = 0;
        for(int i=0; i<n; ++i){
          temp1 = temp1 + (((Y(i,j) - S(i,j))*U(i,l)*D(l,l))/Sigma2);
          temp2 = temp2 + (((Y(i,j) - S2(i,j))*U2(i,l)*D2(l,l))/Sigma22);
        }
        V11(j,l) = temp1;
        V22(j,l) = temp2;
      }
    }
    
    V = rcpp_only_rmf_matrix(V11);
    //    Rcout << "The value of V : \n" << V << "\n";
    V2 = rcpp_only_rmf_matrix(V22);
    //    Rcout << "The value of V2 : \n" << V2 << "\n";
    
    // Update the value of d one at a time for Method 1 and 2
    d = rcpp_only_d_update_mat(clone(d), matrix_multiply(transpose(matrix_multiply(matrix_add(Y, matrix_scalar_multiply(-1, S)), V)), U), Sigma2, n, p, r);
    //    Rcout << "The value of d : \n" << d << "\n";
    d2 = rcpp_only_d_update_mat(clone(d2), matrix_multiply(transpose(matrix_multiply(matrix_add(Y, matrix_scalar_multiply(-1, S2)), V2)), U2), Sigma22, n, p, r);
    //    Rcout << "The value of d2 : \n" << d2 << "\n";
    
    // Once we got the updated set of elements in vector d, it's time to Update D for both Methods
    D = rcpp_only_diag_cumprod(d);
    //    Rcout << "The value of D : \n" << D << "\n";
    D2 = rcpp_only_diag_cumprod(d2);
    //    Rcout << "The value of D2 : \n" << D2 << "\n";
    
    // Update the value of L and then S for Method 1 and 2
    NumericMatrix S_rnorm(n, p);
    NumericMatrix S_runif(n, p);
    NumericMatrix S_rnorm2(n, p);
    for(int j=0; j < p; ++j){
      S_rnorm(_ , j) = Rcpp::rnorm(n, 0, sqrt((tow2 * Sigma2)/(tow2 + Sigma2)));
      S_runif(_ , j) = Rcpp::runif(n, 0, 1);
      S_rnorm2(_ , j) = Rcpp::rnorm(n, 0, sqrt((tow2 * Sigma22)/(tow2 + Sigma22)));
    }
    
    
    NumericMatrix S_MCC(n,p);
    NumericMatrix S_MCC2(n,p);
    
    double rate = 0;
    double rate2 = 0;
    
    for(int i=0; i<n; ++i){
      for(int j=0; j<p; ++j){
        
        // It is needed for updating L
        double temp1 = 0;
        double temp2 = 0;
        for(int l=0; l<r; ++l){
          temp1 = temp1 + (U(i,l)*D(l,l)*V(j,l));
          temp2 = temp2 + (U2(i,l)*D2(l,l)*V2(j,l));
        }
        L(i,j) = temp1;
        L2(i,j) = temp2;    
        
        // Update the value of L_sum and L_hat for Method 1 and 2
        L_sum(i,j) = L_sum(i,j) + L(i,j);
        L_sum2(i,j) = L_sum2(i,j) + L2(i,j);
        L_hat(i,j) = ((double)1/(count + 2)) * L_sum(i,j);
        L_hat2(i,j) = ((double)1/(count + 2)) * L_sum2(i,j);
        
        if(S_runif(i,j) > (q1/(q1 + (((1-q1) * sqrt(Sigma2) * exp((tow2 * pow(Y(i,j) - L(i,j), 2.0))/(2 * Sigma2 * (tow2 + Sigma2))))/sqrt(tow2 + Sigma2))))){
          S_MCC(i,j) = 1;
          S_count(i,j) = S_count(i,j);
        }else{
          S_MCC(i,j) = 0;
          S_count(i,j) = S_count(i,j) + 1;
        }
        
        if(S_runif(i,j) > (q2/(q2 + (((1-q2) * sqrt(Sigma22) * exp((tow2 * pow(Y(i,j) - L2(i,j), 2.0))/(2 * Sigma22 * (tow2 + Sigma22))))/sqrt(tow2 + Sigma22))))){
          S_MCC2(i,j) = 1;
          S_count2(i,j) = S_count2(i,j);
        }else{
          S_MCC2(i,j) = 0;
          S_count2(i,j) = S_count2(i,j) + 1;
        }
        
        S(i,j) = (((tow2/(tow2 + Sigma2))*(Y(i,j) - L(i,j))) + S_rnorm(i,j)) * S_MCC(i,j);
        S2(i,j) = (((tow2/(tow2 + Sigma22))*(Y(i,j) - L2(i,j))) + S_rnorm2(i,j)) * S_MCC2(i,j);
        
        // Update the value of S_sum for Method 1 and 2
        S_sum(i,j) = S_sum(i,j) + S(i,j);
        S_sum2(i,j) = S_sum2(i,j) + S2(i,j);
        
        rate = rate + pow(Y(i,j) - L(i,j) - S(i,j), 2.0);
        rate2 = rate2 + pow(Y(i,j) - L2(i,j) - S2(i,j), 2.0);
      }
    }
    
    //    Rcout << "The value of S : \n" << S << "\n";
    //    Rcout << "The value of S2 : \n" << S2 << "\n";
    // Update the value of Sigma2 for Method 1 and 2
    //    double shape = (n * p * 0.5) + a;
    //    rate = b + (0.5 * rate);
    //    rate2 = b + (0.5 * rate2);
    Sigma2 = rcpp_only_rinvgamma((n * p * 0.5) + a, b + (0.5 * rate));
    Sigma22 = rcpp_only_rinvgamma((n * p * 0.5) + a, b + (0.5 * rate2));
    //    Rcout << "The value of Sigma2 : \n" << Sigma2 << "\n";
    //    Rcout << "The value of Sigma22 : \n" << Sigma22 << "\n";
    
    
    // Update d_sum and d_bar for both Methods
    d_sum = d_sum + d;  // Rcpp only allows element-wise arithmetic operatiosn for vectors, not for matrices.
    //    Rcout << "The value of d_sum : \n" << d_sum << "\n";
    d_sum2 = d_sum2 + d2;
    //    Rcout << "The value of d_sum2 : \n" << d_sum2 << "\n";
    
    d_bar = d_sum/(count + 2);
    //    Rcout << "The value of d_bar : \n" << d_bar << "\n";
    d_bar2 = d_sum2/(count + 2);
    //    Rcout << "The value of d_bar2 : \n" << d_bar2 << "\n";
    
    
    // Update Sigma2_sum and Sigma2_bar for both methods
    Sigma2_sum = Sigma2_sum + Sigma2;
    //    Rcout << "The value of Sigma2_sum : \n" << Sigma2_sum << "\n";
    Sigma2_sum2 = Sigma2_sum2 + Sigma22;
    //    Rcout << "The value of Sigma2_sum2 : \n" << Sigma2_sum2 << "\n";
    
    Sigma2_bar = Sigma2_sum/(count + 2);
    //    Rcout << "The value of Sigma2_bar : \n" << Sigma2_bar << "\n";
    Sigma2_bar2 = Sigma2_sum2/(count + 2);
    //    Rcout << "The value of Sigma2_bar2 : \n" << Sigma2_bar2 << "\n";
    
    
    // Update dbar_list for both methods
    dbar_list[count + 1] = clone(d_bar);
    dbar_list2[count + 1] = clone(d_bar2);
    
    
    // Update the distances for both methods
    distance_d = max(abs(d_bar - d_star));
    //    Rcout << "The value of distance_d : \n" << distance_d << "\n";
    distance_d2 = max(abs(d_bar2 - d_star));
    //    Rcout << "The value of distance_d2 : \n" << distance_d2 << "\n";
    
    distance_Sigma2 = std::abs(Sigma2_bar - 0.01);  // For scalar version, abs() is for int type. Either use std::abs() for double type or fabs() for float type.
    /*  if(Sigma2_bar >= 0.01){
     distance_Sigma2 = Sigma2_bar - 0.01;
    }else{
     distance_Sigma2 = 0.01 - Sigma2_bar;
    }    */
    //    Rcout << "The value of distance_Sigma2 : \n" << distance_Sigma2 << "\n";
    distance_Sigma22 = std::abs(Sigma2_bar2 - 0.01);
    //    Rcout << "The value of distance_Sigma22 : \n" << distance_Sigma22 << "\n";
    
    c1 = c1 + 1;
    c2 = c2 + 1;
    
  }
  
  List Method1 = List::create(_["L"] = L, _["L_hat"] = L_hat, _["U"] = U, _["V"] = V, _["S"] = S, _["S_count"] = S_count, _["S_sum"] = S_sum, _["d"] = d, _["d_bar"] = d_bar, _["dbar_list"] = dbar_list, _["D"] = D, _["Sigma2"] = Sigma2, _["Sigma2_bar"] = Sigma2_bar, _["distance_d"] = distance_d, _["distance_Sigma2"] = distance_Sigma2, _["c1"] = c1);
  List Method2 = List::create(_["L2"] = L2, _["L_hat2"] = L_hat2, _["U2"] = U2, _["V2"] = V2, _["S2"] = S2, _["S_count2"] = S_count2, _["S_sum2"] = S_sum2, _["d2"] = d2, _["d_bar2"] = d_bar2, _["dbar_list2"] = dbar_list2, _["D2"] = D2, _["Sigma22"] = Sigma22, _["Sigma2_bar2"] = Sigma2_bar2, _["distance_d2"] = distance_d2, _["distance_Sigma22"] = distance_Sigma22, _["c2"] = c2);
  return List::create(_["M1"] = Method1, _["M2"] = Method2);
}

/*** R
# User Input
q1 <- 0.95   # For any n, Actual data Y_(n*n) (in particular, S_star_(n*n)) will be generated according to q = 0.95
q2 <- 0.90   # value of q for Method 2, which is q = 0.90
#n_values_seq <- seq.int(from = 50, to = 100, by = 50)  # n = 100:100:300
n_values_seq <- 100

## WE ARE CONSIDERING n*n SQUARE MATRICES ONLY.

## Other input values
a <- 5000 # shape parameter for the inverse gamma distribution of sigma^2  ( should be > 0)        ## CHANGE
b <- 1  # rate parameter for the inverse gamma distribution of sigma^2  ( should be > 0)       ## CHANGE
K <- 40000  # number of iterations
tow2 <- 20   # the variance tow^2 of the normal distribution in the mixture prior of S. For the time-being, it's value is taken to be 10.
burn_in <- 10000

## Load all required packages
library(truncnorm)
library(rstiefel)
library(invgamma)   #as arma_invgamma is used here.
library(pracma)
library(psych)
library(mccr)
library(caret)
library(coda)                   
library(e1071)
library(ggplot2)

## Create the pdf file for traceplots for Method 1: q1 = 0.95 and Method 2: q2 = 0.90
# pdf('5.1.Rcpp_compare_5.1_after=30k_burnin=10k_5000.1.pdf', width = 11.694, height = 8.264)

iterations <- seq(0, (K - burn_in))  # Required for ggplot in Traceplot.

##### Start the simulation for the different methods: Method 1:q = 0.95, Method 2:q = 0.90, Method 3:Inexact ALM - rrpca & Method 4:ALM - Candes.

for(n in n_values_seq){
  
  #n <- 100  #*#
  #r <- 3
  p <- n
  r <- round(0.05*n)    # 1<= r <= n
  
  ##### Actual S_star in actual data is generated according to q = 0.95
  
  # Getting E_star where each entry is iid N(0, 0.01) i.e. actual value of Sigma^2 is 0.01
  #  E_star <- matrix(rnorm(n*p, mean = 0, sd = 0.1), nrow = n, ncol = p)     
  E_star <- matrix(0, nrow = n, ncol = p)
  
  # Getting S_star (according to q1 = 0.95)
  S_star_rnorm <- matrix(rnorm(n*p, mean = 0, sd = sqrt(tow2)), nrow = n, ncol = p)
  S_star_runif <- matrix(runif(n*p), nrow = n, ncol = p)
  S_actual_MCC <- (S_star_runif > q1)*1
  S_star <- S_star_rnorm * S_actual_MCC
  
  # Getting U_star of order n*r
  # generate a random orthonormal matrix of order n*n. The randomness is meant w.r.t (additively invariant) Haar measure on O(n).
  U_star <- randortho(n, type = "orthonormal")[ ,1:r]                         #takes the first r many columns
  
  # Getting V_star of order p*r
  V_star <- randortho(p, type = "orthonormal")[ ,1:r]
  
  # Getting D_star of order r*r
  d_star <- c(runif(r-1, min = 1, max = 2), runif(1, min = 0.5, max = 1.5))          ## CHANGE
  #print(d_star)
  
  D_star <- rcpp_only_diag_cumprod(d_star)
  #print(D_star)
  
  L_star <- U_star %*% D_star %*% t(V_star)
  
  ## Define the true model
  Y <- (U_star %*% D_star %*% t(V_star)) + S_star + E_star
  #print(Y)
  
  #################### AFTER GENERATING TRUE DATA Y
  
  ##### Method 1 & 2: Our method where prior being generated with q = 0.95 and q = 0.90
  
  ## Simulation of E from the prior of sigma^2
  Sigma20 <- rcpp_only_rinvgamma(a, b)     # same as rinvgamma(1, shape = a, rate = b)
  #print(Sigma20)
  
  ## Simulation of S from the prior which is 0 w.p q [where, q = 1 - 1/p] and N(0,tow2) w.p (1-q)
  ## and also getting intial value of S_count
  S0_rnorm <- matrix(rnorm(n*p, mean = 0, sd = sqrt(tow2)), nrow = n, ncol = p)
  S0_runif <- matrix(runif(n*p), nrow = n, ncol = p)
  S0_MCC <- (S0_runif > q1)*1
  S0_MCC2 <- (S0_runif > q2)*1
  S0 <- S0_rnorm * S0_MCC
  S02 <- S0_rnorm * S0_MCC2
  #print(S0)  
  S0_count <- (S0_runif < q1)*1        #For any element of S0_count, it puts 1 when any element of S0 is 0.
  S0_count2 <- (S0_runif < q2)*1
  #print(S0_count)
  
  ## Simulation of D of order r*r from prior of d
  d0 <- c(rtruncnorm(r-1, a=1, b=Inf, mean=0, sd=1), rtruncnorm(1, a=0, b=Inf, mean=0, sd=1))
  #print("Initial choice of d")
  #print(d0)
  D0 <- rcpp_only_diag_cumprod(d0)
  #print(D0)
  
  ## Simulation of U of order n*r from uniform prior on the stiefel manifold R^(n*r)
  U0 <- rcpp_only_rustiefel(n,r)
  #print(U0)
  
  ## Simulation of V of order p*r from uniform prior on the stiefel manifold R^(p*r)
  V0 <- rcpp_only_rustiefel(p,r)
  #print(V0)
  
  L0 <- U0 %*% D0 %*% t(V0)
  #print(L0)
  
  ### Simulation from the full conditional posterior distributions with K many iterations.
  ## Initially we take the input values of U, V, d, D, S, Sigma2 and L to be above 
  ## values which we got initially after simulation from their respective priors.
  ## BURN IN 
  
  Simul_burnin_list <- Simul_burnin(Y, U0, U0, D0, D0, V0, V0, S0, S02, d0, d0, Sigma20, Sigma20, tow2, q1, q2, n, p, r, burn_in, a, b)
  
  
  ## Output AFTER BURN IN
  U0 <- Simul_burnin_list[["U"]]
  #print(U0)
  U02 <- Simul_burnin_list[["U2"]]
  #print(U02)
  
  V0 <- Simul_burnin_list[["V"]]
  #print(V0)
  V02 <- Simul_burnin_list[["V2"]]
  #print(V02)
  
  d0 <- Simul_burnin_list[["d"]]
  #print("After Burn in d")
  #print(d0)
  d02 <- Simul_burnin_list[["d2"]]
  #print("After Burn in d2")
  #print(d02)
  
  D0 <- Simul_burnin_list[["D"]]
  #print(D0)
  D02 <- Simul_burnin_list[["D2"]]
  #print(D02)
  
  L0 <- Simul_burnin_list[["L"]]
  #print(L0)
  L02 <- Simul_burnin_list[["L2"]]
  #print(L02)
  
  S0 <- Simul_burnin_list[["S"]]
  #print(S0)
  S02 <- Simul_burnin_list[["S2"]]
  #print(S02)
  
  S0_count <- Simul_burnin_list[["S_count"]]
  #print(S0_count)
  S0_count2 <- Simul_burnin_list[["S_count2"]]
  #print(S0_count2)
  
  Sigma20 <- Simul_burnin_list[["Sigma2"]]
  #print(Sigma20)
  Sigma202 <- Simul_burnin_list[["Sigma22"]]
  #print(Sigma202)
  
  ## Output AFTER ALL iterations
  
  Simul_afterburnin_list <- Simul_after_burnin(Y, U0, U02, D0, D02, V0, V02, L0, L02, S0, S02, S0_count, S0_count2, d0, d02, d_star, Sigma20, Sigma202, tow2, q1, q2, n, p, r, K, burn_in, a, b)
  
  L_hat <- Simul_afterburnin_list[["M1"]][["L_hat"]]
  L_hat2 <- Simul_afterburnin_list[["M2"]][["L_hat2"]]
  
  S_count <- Simul_afterburnin_list[["M1"]][["S_count"]]
  S_count2 <- Simul_afterburnin_list[["M2"]][["S_count2"]]
  
  S_sum <- Simul_afterburnin_list[["M1"]][["S_sum"]]
  S_sum2 <- Simul_afterburnin_list[["M2"]][["S_sum2"]]
  
  d_bar <- Simul_afterburnin_list[["M1"]][["d_bar"]]    # d_bar at the last iteration for Method 1
  #print(d_bar)
  #Simul_afterburnin_list[["M1"]][["d"]]
  #Simul_burnin_list[["d"]]  
  d_bar2 <- Simul_afterburnin_list[["M2"]][["d_bar2"]]    # d_bar at the last iteration for Method 2
  #print(d_bar2)
  #Simul_afterburnin_list[["M2"]][["d2"]]
  #Simul_burnin_list[["d2"]]
  
  dbar_list <- Simul_afterburnin_list[["M1"]][["dbar_list"]]
  dbar_list2 <- Simul_afterburnin_list[["M2"]][["dbar_list2"]]
  
  Sigma2_bar <- Simul_afterburnin_list[["M1"]][["Sigma2_bar"]]
  Sigma2_bar2 <- Simul_afterburnin_list[["M2"]][["Sigma2_bar2"]]
  
  distance_d <- Simul_afterburnin_list[["M1"]][["distance_d"]]
  distance_d2 <- Simul_afterburnin_list[["M2"]][["distance_d2"]]
  
  distance_Sigma2 <- Simul_afterburnin_list[["M1"]][["distance_Sigma2"]]
  distance_Sigma22 <- Simul_afterburnin_list[["M2"]][["distance_Sigma22"]]
  
  ##### Outputs for Method 1, Method 2, Method 3(Inexact ALM - rrpca) and Method 4(ALM - Candes):
  
  ## Getting S_hat, estimate of S_star for Method 1:
  J <- matrix(1, nrow = n, ncol = p)       # matrix whose all elements are 1
  avg_S <- S_sum / ((K - burn_in + 1)*J - S_count)
  avg_S[!is.finite(avg_S)] <- 0            # If for any elemnet of avg_S, denom is 0, then NA is replaced by 0 
  # since in that case, S_count[i,j] = (K+1), which is >= (K+1)/2.
  S_predicted_MCC <- (S_count < ((K - burn_in + 1)/2))*1
  S_hat <- avg_S * S_predicted_MCC
  
  ## Getting S_hat2, estimate of S_star for Method 2:
  avg_S2 <- S_sum2 / ((K - burn_in + 1)*J - S_count2)
  avg_S2[!is.finite(avg_S2)] <- 0            # If for any elemnet of avg_S2, denom is 0, then NA is replaced by 0 
  # since in that case, S_count2[i,j] = (K+1), which is >= (K+1)/2.
  S_predicted_MCC2 <- (S_count2 < ((K - burn_in + 1)/2))*1
  S_hat2 <- avg_S2 * S_predicted_MCC2
  
  ## Getting L_hat_IALM and S_hat_IALM, estimates of L_star and S_star respectively for Method 3: Inexact ALM - rrpca.
  library(rsvd)
  L_hat_IALM <- rrpca(Y, maxiter = 500)$L        # default maxiter = 50
  S_hat_IALM <- rrpca(Y, maxiter = 500)$S
  S_predicted_MCC_IALM <- (S_hat_IALM != 0)*1
  
  ## Getting L_hat_rpca and S_hat_rpca, estimates of L_star and S_star respectively for Method 4: ALM - Candes.
  detach("package:rsvd", unload = T)
  library(rpca)
  L_hat_rpca <- rpca(Y, max.iter = 5000)$L       # default max.iter = 5000
  S_hat_rpca <- rpca(Y, max.iter = 5000)$S
  S_predicted_MCC_rpca <- (S_hat_rpca != 0)*1
  
  print("The value of n and p")
  print(n)
  print(p)
  print("Does rpca function (ALM algorithm described in candes paper) converge for by default max iteration = 5000? If TRUE then YES")
  print(rpca(Y)$convergence$converged)         # rpca(Y, max.iter = m)$convergence$converged ,if m is not 5000.
  print("Number of performed iterations")
  print(rpca(Y)$convergence$iterations)        # rpca(Y, max.iter = m)$convergence$iterations ,if m is not 5000.
  
  ## Finding sensitivity and specificity for all Methods:
  S_actual_factor <- factor(as.factor(S_actual_MCC), levels = c("0", "1"))     ## for the Actual data.
  S_predic_factor <- factor(as.factor(S_predicted_MCC), levels = c("0", "1"))  ## for Method 1: q = 0.95
  S_predic_factor2 <- factor(as.factor(S_predicted_MCC2), levels = c("0", "1"))  ## for Method 2: q = 0.90
  S_predic_factor_IALM <- factor(as.factor(S_predicted_MCC_IALM), levels = c("0", "1"))  ## for Method 3: Inexact ALM - rrpca
  S_predic_factor_rpca <- factor(as.factor(S_predicted_MCC_rpca), levels = c("0", "1"))  ## for Method 4: ALM - Candes
  
  print("Sensitivity and Specificity for Method 1: q = 0.95")
  print(sensitivity(S_predic_factor, S_actual_factor, positive = "1"))
  print(specificity(S_predic_factor, S_actual_factor, negative = "0"))
  print("Sensitivity and Specificity for Method 2: q = 0.90")
  print(sensitivity(S_predic_factor2, S_actual_factor, positive = "1"))
  print(specificity(S_predic_factor2, S_actual_factor, negative = "0"))
  print("Sensitivity and Specificity for Method 3: Inexact ALM - rrpca")
  print(sensitivity(S_predic_factor_IALM, S_actual_factor, positive = "1"))
  print(specificity(S_predic_factor_IALM, S_actual_factor, negative = "0"))
  print("Sensitivity and Specificity for Method 4: ALM - Candes")
  print(sensitivity(S_predic_factor_rpca, S_actual_factor, positive = "1"))
  print(specificity(S_predic_factor_rpca, S_actual_factor, negative = "0"))
  
  ## Mattews Correlation Coefficient for all Methods:
  print("Mattews Correlation Coefficient(MCC) for S for Method 1: q = 0.95")
  print(mccr(S_actual_MCC, S_predicted_MCC))        # 0 is taken as 0(negative) and non-zero values are taken as 1 (positive)
  print("Mattews Correlation Coefficient(MCC) for S for Method 2: q = 0.90")
  print(mccr(S_actual_MCC, S_predicted_MCC2))        # 0 is taken as 0(negative) and non-zero values are taken as 1 (positive)
  print("Mattews Correlation Coefficient(MCC) for S for Method 3: Inexact ALM - rrpca")
  print(mccr(S_actual_MCC, S_predicted_MCC_IALM))        # 0 is taken as 0(negative) and non-zero values are taken as 1 (positive)
  print("Mattews Correlation Coefficient(MCC) for S for Method 4: ALM - Candes")
  print(mccr(S_actual_MCC, S_predicted_MCC_rpca))        # 0 is taken as 0(negative) and non-zero values are taken as 1 (positive)
  
  ## Finding Relative Ratio for L and S for all Methods:
  print("Relative Ratio for L and S for Method 1: q = 0.95")
  print(norm(L_star - L_hat, type = "F")/ norm(L_star, type = "F"))  # Frobenius norm distance
  print(norm(S_star - S_hat, type = "F")/ norm(S_star, type = "F"))  # Frobenius norm distance
  print("Relative Ratio for L and S for Method 2: q = 0.90")
  print(norm(L_star - L_hat2, type = "F")/ norm(L_star, type = "F"))  # Frobenius norm distance
  print(norm(S_star - S_hat2, type = "F")/ norm(S_star, type = "F"))  # Frobenius norm distance
  print("Relative Ratio for L and S for Method 3: Inexact ALM - rrpca")
  print(norm(L_star - L_hat_IALM, type = "F")/ norm(L_star, type = "F"))  # Frobenius norm distance
  print(norm(S_star - S_hat_IALM, type = "F")/ norm(S_star, type = "F"))  # Frobenius norm distance
  print("Relative Ratio for L and S for Method 4: ALM - Candes")
  print(norm(L_star - L_hat_rpca, type = "F")/ norm(L_star, type = "F"))  # Frobenius norm distance
  print(norm(S_star - S_hat_rpca, type = "F")/ norm(S_star, type = "F"))  # Frobenius norm distance
  
  ## Maximum modulus of all the elements in (L_star - L_hat) for all Methods:
  print("Maximum modulus of all the elements in (L_star - L_hat) for Method 1: q = 0.95")
  print(max(abs(L_star - L_hat)))
  print("Maximum modulus of all the elements in (L_star - L_hat) for Method 2: q = 0.90")
  print(max(abs(L_star - L_hat2)))
  print("Maximum modulus of all the elements in (L_star - L_hat) for Method 3: Inexact ALM - rrpca")
  print(max(abs(L_star - L_hat_IALM)))
  print("Maximum modulus of all the elements in (L_star - L_hat) for Method 4: ALM - Candes")
  print(max(abs(L_star - L_hat_rpca)))
  
  ## Maximum modulus of all the elements in (S_star - S_hat) for all Methods:
  print("Maximum modulus of all the elements in (S_star - S_hat) for Method 1: q = 0.95")
  print(max(abs(S_star - S_hat)))
  print("Maximum modulus of all the elements in (S_star - S_hat) for Method 2: q = 0.90")
  print(max(abs(S_star - S_hat2)))
  print("Maximum modulus of all the elements in (S_star - S_hat) for Method 3: Inexact ALM - rrpca")
  print(max(abs(S_star - S_hat_IALM)))
  print("Maximum modulus of all the elements in (S_star - S_hat) for Method 4: ALM - Candes")
  print(max(abs(S_star - S_hat_rpca)))
  
  dbar_array <- simplify2array(dbar_list)                                                       
  dbar_array2 <- simplify2array(dbar_list2)
  
  
  for (i in 1:r) {
    daf <- data.frame(iterations, mcmc(dbar_array[i,]), mcmc(dbar_array2[i,]))
    ## About ggplot below: when inside a loop, you have to print your ggplot object. If outside a loop, without print function works fine.
    print(ggplot(daf, aes(iterations)) + 
            geom_line(aes(y = mcmc(dbar_array[i,])), colour="Black") +    # 1st layer of plot with q = 0.95
            geom_line(aes(y = mcmc(dbar_array2[i,])), colour="Blue") +    # 2nd layer of plot with q = 0.90
            geom_hline(yintercept = d_star[i], colour="Red") +              # 3rd layer with the actual value of d_star[i]
            theme_gray() +
            labs(title = paste("Trace Plot of d_bar[", i, "]", ", when n =", n, "\n Black: q = 0.95, Blue: q = 0.90, Red: d_star[", i, "]", "=", round(d_star[i], digits = 5)), y = paste("d_bar[", i, "]")) + 
            theme(plot.title = element_text(hjust = 0.5)) +   # By default, title is left aligned in ggplot. Use it to center the titile.
            coord_cartesian(ylim = c(0, 5)))
  }
  
  print("d_star")
  print(d_star)
  print("d_bar at the last iteration for Method 1")
  print(d_bar)
  print("d_bar at the last iteration for Method 2")
  print(d_bar2)
  print("L infinity distance between d_bar and d_star at the last iteration for Method 1")
  print(distance_d)
  print("L infinity distance between d_bar2 and d_star at the last iteration for Method 2")
  print(distance_d2)
  #print("Sigma2_bar at the last iteration")
  #print(Sigma2_bar)
  print("Absolute distance between Sigma2_bar and 0.01 at the last iteration for Method 1")
  print(distance_Sigma2)
  print("Absolute distance between Sigma2_bar2 and 0.01 at the last iteration for Method 2")
  print(distance_Sigma22)
  
}   # end of for loop for n_values
# dev.off()  
*/
